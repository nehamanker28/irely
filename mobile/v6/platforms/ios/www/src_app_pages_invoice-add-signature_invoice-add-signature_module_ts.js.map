{"version":3,"sources":["./node_modules/signature_pad/dist/signature_pad.js","./src/app/pages/invoice-add-signature/invoice-add-signature-routing.module.ts","./src/app/pages/invoice-add-signature/invoice-add-signature.module.ts","./src/app/pages/invoice-add-signature/invoice-add-signature.page.ts","./src/app/pages/invoice-add-signature/invoice-add-signature.page.scss","./src/app/pages/invoice-add-signature/invoice-add-signature.page.html"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe,sBAAsB,eAAe,KAAK,eAAe,oBAAoB,eAAe;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B,GAAG,8BAA8B;AACjG,yBAAyB,4BAA4B,GAAG,4BAA4B;AACpF,uBAAuB,4BAA4B,GAAG,4BAA4B;AAClF,uBAAuB,4BAA4B,GAAG,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;AACA;AACA,yBAAyB,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK;AACtD,uBAAuB,KAAK;AAC5B,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,YAAY,EAAC;AAC5B;;;;;;;;;;;;;;;;;;;;;AC/eyC;AACc;AAEgB;AAEvE,MAAM,MAAM,GAAW;IACrB;QACE,IAAI,EAAE,EAAE;QACR,SAAS,EAAE,gFAAuB;KACnC;CACF,CAAC;IAMW,oCAAoC,SAApC,oCAAoC;CAAG;AAAvC,oCAAoC;IAJhD,uDAAQ,CAAC;QACR,OAAO,EAAE,CAAC,kEAAqB,CAAC,MAAM,CAAC,CAAC;QACxC,OAAO,EAAE,CAAC,yDAAY,CAAC;KACxB,CAAC;GACW,oCAAoC,CAAG;AAAH;;;;;;;;;;;;;;;;;;;;;;;;AChBR;AACM;AACF;AAEA;AAEiD;AAEvB;IAW1D,6BAA6B,SAA7B,6BAA6B;CAAG;AAAhC,6BAA6B;IATzC,uDAAQ,CAAC;QACR,OAAO,EAAE;YACP,yDAAY;YACZ,uDAAW;YACX,uDAAW;YACX,uGAAoC;SACrC;QACD,YAAY,EAAE,CAAC,gFAAuB,CAAC;KACxC,CAAC;GACW,6BAA6B,CAAG;AAAH;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnB4D;AACvD;AACN;AAC6B;AACK;AACC;IAO/D,uBAAuB,SAAvB,uBAAuB;IAOlC,YAAoB,UAAsB,EAAU,kBAAsC,EAAU,eAAgC,EAAS,OAAsB,EAAU,mBAAwC;QAAjM,eAAU,GAAV,UAAU,CAAY;QAAU,uBAAkB,GAAlB,kBAAkB,CAAoB;QAAU,oBAAe,GAAf,eAAe,CAAiB;QAAS,YAAO,GAAP,OAAO,CAAe;QAAU,wBAAmB,GAAnB,mBAAmB,CAAqB;IAAI,CAAC;IAE1N,QAAQ;QACN,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAGD,QAAQ,CAAC,KAAK;QACZ,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED,IAAI;QACF,MAAM,MAAM,GAAQ,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QAC1E,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC;QACjC,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,WAAW,GAAG,GAAG,CAAC;QACzC,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC,CAAC,wBAAwB;SACpD;IACH,CAAC;IAEM,eAAe;QACpB,IAAI,CAAC,YAAY,GAAG,IAAI,kDAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;QAC7E,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,CAAC,YAAY,CAAC,QAAQ,GAAG,iBAAiB,CAAC;IACjD,CAAC;IAED,IAAI;QACF,IAAI,EAAE,GAAG,IAAI,CAAC;QACd,EAAE,CAAC,kBAAkB,CAAC,eAAe,CAAC,EAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC,sBAAsB,CAAC,CAAC,IAAI,CACjG,MAAM,CAAC,EAAE;YACP,IAAI,MAAM,CAAC,aAAa,EAAE;gBACxB,MAAM,GAAG,GAAG,EAAE,CAAC,YAAY,CAAC,SAAS,EAAE,CAAC;gBACxC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACjB,EAAE,CAAC,QAAQ,GAAG,GAAG,CAAC;gBAClB,EAAE,CAAC,IAAI,EAAE,CAAC;gBAEV,gDAAgD;gBAChD,aAAa;gBACb,mDAAmD;gBACnD,yBAAyB;gBACzB,iBAAiB;gBACjB,OAAO;gBACP,8DAA8D;gBAC9D,KAAK;aACN;iBACI;gBACH,EAAE,CAAC,kBAAkB,EAAE,CAAC;aACzB;QACH,CAAC,EACD,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,kBAAkB,EAAE,CAC/B,CAAC;IACJ,CAAC;IAED,kBAAkB;QAChB,IAAI,EAAE,GAAG,IAAI,CAAC;QACd,EAAE,CAAC,kBAAkB,CAAC,kBAAkB,CAAC;YACvC,EAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC,qBAAqB;YACtD,EAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC,sBAAsB;SAAC,CAAC;aACxD,IAAI,CACH,GAAG,CAAC,EAAE;YACJ,OAAO,CAAC,GAAG,CAAC,yBAAyB,EAAE,GAAG,CAAC,CAAC;YAC5C,EAAE,CAAC,IAAI,EAAE,CAAC;QACZ,CAAC,EACD,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,gCAAgC,EAAE,GAAG,CAAC,CAC1D,CAAC;IACN,CAAC;IAED,IAAI;QACF,IAAI,EAAE,GAAG,IAAI,CAAC;QACd,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QAEzB,EAAE,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;YACzB,EAAE,CAAC,mBAAmB,CAAC,sBAAsB,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;IACL,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;SACnD;IACH,CAAC;IAED,KAAK;QACH,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;IAC5B,CAAC;IAED,IAAI;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;QACxC,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,8BAA8B;YAC1C,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAClC;IACH,CAAC;CACF;;YAhHoD,qDAAU;YAItD,qFAAkB;YADlB,gFAAe;YAFf,yDAAa;YAIb,iFAAmB;;;kCAQzB,oDAAS,SAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE;uBAYpC,uDAAY,SAAC,eAAe,EAAE,CAAC,QAAQ,CAAC;;AAb9B,uBAAuB;IALnC,wDAAS,CAAC;QACT,QAAQ,EAAE,2BAA2B;QACrC,0FAAgD;;KAEjD,CAAC;GACW,uBAAuB,CAoGnC;AApGmC;;;;;;;;;;;;;;;;ACZpC,iEAAe,SAAS,4BAA4B,gBAAgB,iBAAiB,GAAG,6CAA6C,+WAA+W,E;;;;;;;;;;;;;;;ACApf,iEAAe,mnCAAmnC,mDAAmD,E","file":"src_app_pages_invoice-add-signature_invoice-add-signature_module_ts.js","sourcesContent":["/*!\n * Signature Pad v3.0.0-beta.4 | https://github.com/szimek/signature_pad\n * (c) 2020 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, time) {\n        this.x = x;\n        this.y = y;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y && this.time === other.time;\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.options = options;\n        this._handleMouseDown = (event) => {\n            if (event.which === 1) {\n                this._mouseButtonDown = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._mouseButtonDown) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.which === 1 && this._mouseButtonDown) {\n                this._mouseButtonDown = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            event.preventDefault();\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            event.preventDefault();\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                event.preventDefault();\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options\n            ? options.minDistance\n            : 5);\n        this.dotSize =\n            options.dotSize ||\n                function dotSize() {\n                    return (this.minWidth + this.maxWidth) / 2;\n                };\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this.onBegin = options.onBegin;\n        this.onEnd = options.onEnd;\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset();\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}, callback) {\n        const image = new Image();\n        const ratio = options.ratio || window.devicePixelRatio || 1;\n        const width = options.width || this.canvas.width / ratio;\n        const height = options.height || this.canvas.height / ratio;\n        this._reset();\n        image.onload = () => {\n            this._ctx.drawImage(image, 0, 0, width, height);\n            if (callback) {\n                callback();\n            }\n        };\n        image.onerror = (error) => {\n            if (callback) {\n                callback(error);\n            }\n        };\n        image.src = dataUrl;\n        this._isEmpty = false;\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                return this._toSVG();\n            default:\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        if (window.PointerEvent) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n        document.removeEventListener('pointerup', this._handleMouseUp);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        document.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups) {\n        this.clear();\n        this._fromData(pointGroups, ({ color, curve }) => this._drawCurve({ color, curve }), ({ color, point }) => this._drawDot({ color, point }));\n        this._data = pointGroups;\n    }\n    toData() {\n        return this._data;\n    }\n    _strokeBegin(event) {\n        const newPointGroup = {\n            color: this.penColor,\n            points: [],\n        };\n        if (typeof this.onBegin === 'function') {\n            this.onBegin(event);\n        }\n        this._data.push(newPointGroup);\n        this._reset();\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const point = this._createPoint(x, y);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const color = lastPointGroup.color;\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point);\n            if (!lastPoint) {\n                this._drawDot({ color, point });\n            }\n            else if (curve) {\n                this._drawCurve({ color, curve });\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n            });\n        }\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        if (typeof this.onEnd === 'function') {\n            this.onEnd(event);\n        }\n    }\n    _handlePointerEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.addEventListener('pointermove', this._handleMouseMove);\n        document.addEventListener('pointerup', this._handleMouseUp);\n    }\n    _handleMouseEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        document.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset() {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n        this._ctx.fillStyle = this.penColor;\n    }\n    _createPoint(x, y) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, new Date().getTime());\n    }\n    _addPoint(point) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint) {\n        const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - this.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity) {\n        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve({ color, curve }) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.floor(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot({ color, point, }) {\n        const ctx = this._ctx;\n        const width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { color, points } = group;\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);\n                    this.penColor = color;\n                    if (j === 0) {\n                        this._reset();\n                    }\n                    const curve = this._addPoint(point);\n                    if (curve) {\n                        drawCurve({ color, curve });\n                    }\n                }\n            }\n            else {\n                this._reset();\n                drawDot({\n                    color,\n                    point: points[0],\n                });\n            }\n        }\n    }\n    _toSVG() {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('width', this.canvas.width.toString());\n        svg.setAttribute('height', this.canvas.height.toString());\n        this._fromData(pointGroups, ({ color, curve }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', color);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, ({ color, point }) => {\n            const circle = document.createElement('circle');\n            const dotSize = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n            circle.setAttribute('r', dotSize.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', color);\n            svg.appendChild(circle);\n        });\n        const prefix = 'data:image/svg+xml;base64,';\n        const header = '<svg' +\n            ' xmlns=\"http://www.w3.org/2000/svg\"' +\n            ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' +\n            ` viewBox=\"${minX} ${minY} ${maxX} ${maxY}\"` +\n            ` width=\"${maxX}\"` +\n            ` height=\"${maxY}\"` +\n            '>';\n        let body = svg.innerHTML;\n        if (body === undefined) {\n            const dummy = document.createElement('dummy');\n            const nodes = svg.childNodes;\n            dummy.innerHTML = '';\n            for (let i = 0; i < nodes.length; i += 1) {\n                dummy.appendChild(nodes[i].cloneNode(true));\n            }\n            body = dummy.innerHTML;\n        }\n        const footer = '</svg>';\n        const data = header + body + footer;\n        return prefix + btoa(data);\n    }\n}\n\nexport default SignaturePad;\n//# sourceMappingURL=signature_pad.js.map\n","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { InvoiceAddSignaturePage } from './invoice-add-signature.page';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: InvoiceAddSignaturePage\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class InvoiceAddSignaturePageRoutingModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\nimport { IonicModule } from '@ionic/angular';\n\nimport { InvoiceAddSignaturePageRoutingModule } from './invoice-add-signature-routing.module';\n\nimport { InvoiceAddSignaturePage } from './invoice-add-signature.page';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    IonicModule,\n    InvoiceAddSignaturePageRoutingModule\n  ],\n  declarations: [InvoiceAddSignaturePage]\n})\nexport class InvoiceAddSignaturePageModule {}\n","import { Component, OnInit, ViewChild, HostListener, ElementRef, AfterViewInit } from '@angular/core';\nimport { NavController } from '@ionic/angular';\nimport SignaturePad from 'signature_pad';\nimport { Base64ToGallery } from '@ionic-native/base64-to-gallery/ngx';\nimport { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\nimport { GlobalEventsService } from '../../providers/global-events.service';\n\n@Component({\n  selector: 'app-invoice-add-signature',\n  templateUrl: './invoice-add-signature.page.html',\n  styleUrls: ['./invoice-add-signature.page.scss'],\n})\nexport class InvoiceAddSignaturePage implements OnInit, AfterViewInit {\n  @ViewChild('canvas', { static: true }) signaturePadElement;\n  signaturePad: any;\n  canvasWidth: number;\n  canvasHeight: number;\n  imageUrl: string;\n\n  constructor(private elementRef: ElementRef, private androidPermissions: AndroidPermissions, private base64ToGallery: Base64ToGallery, public navCtrl: NavController, private globalEventsService: GlobalEventsService) { }\n\n  ngOnInit(): void {\n    this.init();\n  }\n\n  @HostListener('window:resize', ['$event'])\n  onResize(event) {\n    this.init();\n  }\n\n  init() {\n    const canvas: any = this.elementRef.nativeElement.querySelector('canvas');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight - 140;\n    if (this.signaturePad) {\n      this.signaturePad.clear(); // Clear the pad on init\n    }\n  }\n\n  public ngAfterViewInit(): void {\n    this.signaturePad = new SignaturePad(this.signaturePadElement.nativeElement);\n    this.signaturePad.clear();\n    this.signaturePad.penColor = 'rgb(56,128,255)';\n  }\n\n  save(): void {\n    var me = this;\n    me.androidPermissions.checkPermission(me.androidPermissions.PERMISSION.WRITE_EXTERNAL_STORAGE).then(\n      result => {\n        if (result.hasPermission) {\n          const img = me.signaturePad.toDataURL();\n          console.log(img);\n          me.imageUrl = img;\n          me.Okay();\n\n          // me.base64ToGallery.base64ToGallery(img).then(\n          //   res => {\n          //     console.log('Saved image to gallery ', res);\n          //     me.imageUrl = res;\n          //     me.Okay();\n          //   },\n          //   err => console.log('Error saving image to gallery ', err)\n          // );\n        }\n        else {\n          me.requestPermissions();\n        }\n      },\n      err => me.requestPermissions()\n    );\n  }\n\n  requestPermissions() {\n    var me = this;\n    me.androidPermissions.requestPermissions([\n      me.androidPermissions.PERMISSION.READ_EXTERNAL_STORAGE,\n      me.androidPermissions.PERMISSION.WRITE_EXTERNAL_STORAGE])\n      .then(\n        res => {\n          console.log('Saved image to gallery ', res);\n          me.save();\n        },\n        err => console.log('Error saving image to gallery ', err)\n      );\n  }\n\n  Okay(){\n    var me = this;\n    console.log(me.imageUrl);\n\n    me.navCtrl.pop().then(() => {\n      me.globalEventsService.publishEventsSignature(me.imageUrl);\n    });\n  }\n\n  isCanvasBlank(): boolean {\n    if (this.signaturePad) {\n      return this.signaturePad.isEmpty() ? true : false;\n    }\n  }\n\n  clear() {\n    this.signaturePad.clear();\n  }\n\n  undo() {\n    const data = this.signaturePad.toData();\n    if (data) {\n      data.pop(); // remove the last dot or line\n      this.signaturePad.fromData(data);\n    }\n  }\n}","export default \"canvas {\\n  border: 3px dashed gray;\\n  width: 100%;\\n  height: 100%;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImludm9pY2UtYWRkLXNpZ25hdHVyZS5wYWdlLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDSSx1QkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0FBQ0oiLCJmaWxlIjoiaW52b2ljZS1hZGQtc2lnbmF0dXJlLnBhZ2Uuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbImNhbnZhcyB7XG4gICAgYm9yZGVyOiAzcHggZGFzaGVkIGdyYXk7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufSJdfQ== */\";","export default \"<ion-header>\\n  <ion-toolbar class=\\\"my-toolbar box-shadow\\\" >\\n    <ion-buttons slot=\\\"start\\\">\\n      <ion-back-button></ion-back-button>\\n    </ion-buttons>\\n    <ion-grid no-padding>\\n      <ion-row>        \\n        <ion-col col-auto></ion-col>\\n        <ion-col size=\\\"2.5\\\">\\n          <ion-button ion-button expand=\\\"block\\\" size=\\\"large\\\"primary [disabled]=\\\"isCanvasBlank()\\\" (click)=\\\"save()\\\" class=\\\"button-global\\\"> Save </ion-button>          \\n        </ion-col>\\n        <ion-col size=\\\"2\\\">\\n          <ion-button ion-button expand=\\\"block\\\" size=\\\"large\\\"primary (click)=\\\"undo()\\\" class=\\\"button-global\\\"> Undo </ion-button>          \\n        </ion-col>\\n        <ion-col size=\\\"2\\\">\\n          <ion-button ion-button expand=\\\"block\\\" size=\\\"large\\\"primary (click)=\\\"clear()\\\" class=\\\"button-global\\\"> Clear </ion-button>          \\n        </ion-col>\\n      </ion-row>\\n    </ion-grid>\\n  </ion-toolbar>  \\n</ion-header>\\n\\n<ion-content class=\\\"ion-padding\\\">\\n\\n  <div class=\\\"signature-pad\\\">\\n    <div>\\n      <canvas class=\\\"signature-pad-canvas\\\" #canvas width=\\\"900\\\" height=\\\"400\\\" style=\\\"touch-action: none;\\\"></canvas>\\n    </div>\\n  </div>\\n</ion-content>\";"],"sourceRoot":"webpack:///"}